# Custom Thread Pool Executor

## Описание проекта
Данный проект представляет собой реализацию собственного пула потоков на языке Java, реализующего интерфейс `CustomExecutor`. Реализованный пул позволяет настраивать количество потоков, очередь задач, время жизни потоков и политику отказа в выполнении задач.

## Архитектура
Проект состоит из следующих основных компонентов:
- **CustomThreadPoolExecutor**: основной класс, реализующий логику управления пулом потоков и очередью задач.
- **CustomThreadFactory**: кастомная реализация интерфейса `ThreadFactory` для создания потоков с уникальными именами и логированием.
- **CustomRejectedExecutionHandler**: реализация интерфейса `RejectedExecutionHandler`, задающая поведение при переполнении пула и очереди задач.
- **DemoTask и DemoCallableTask**: демонстрационные задачи для проверки работы пула (Runnable и Callable).

## Почему выбран именно такой подход?
- **ThreadFactory**: Реализация кастомной фабрики потоков позволяет удобно отслеживать создание и завершение потоков благодаря понятным уникальным именам и логированию.
- **RejectedExecutionHandler**: Реализация кастомного обработчика отказов позволяет чётко отслеживать и логировать случаи переполнения очереди задач, что важно при высокой нагрузке.
- **AtomicInteger**: Использование `AtomicInteger` для управления количеством потоков обеспечивает потокобезопасность и производительность.

## Анализ производительности
### Сравнение со стандартным ThreadPoolExecutor
Тестирование показало, что кастомный пул потоков демонстрирует производительность, близкую к стандартному `ThreadPoolExecutor`, при аналогичных параметрах. Основные отличия заключаются в лучшем контроле над поведением при переполнении и более прозрачном логировании жизненного цикла потоков.

### Влияние параметров на производительность
- **corePoolSize**: увеличение данного параметра улучшает обработку задач при стабильной нагрузке, снижая время ожидания выполнения.
- **maxPoolSize**: больший показатель помогает справиться с пиковыми нагрузками, но ведёт к дополнительным затратам на создание временных потоков.
- **keepAliveTime**: слишком короткое значение приводит к частому созданию и удалению временных потоков, ухудшая производительность. Оптимальным в тестах показалось значение около 5-10 секунд.
- **Размер очереди (BlockingQueue)**: ограничение очереди позволяет избегать перегрузки памяти при высокой нагрузке, однако слишком маленькое значение приводит к частым отказам в принятии задач.

## Итоги тестирования
### Поведение при нагрузке и отказах
При превышении возможностей пула (максимальное число потоков занято, очередь заполнена) корректно срабатывает обработчик отказов с логированием и выбросом исключения. Такое поведение позволяет разработчику оперативно реагировать на перегрузку системы.

### Корректность завершения работы пула
Методы `shutdown()` и `shutdownNow()` протестированы и работают корректно, завершая потоки и возвращая неисполненные задачи при необходимости. Завершение работы пула осуществляется плавно и без потери задач.



